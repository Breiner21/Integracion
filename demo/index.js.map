{
  "version": 3,
  "sources": ["../../../src/webauthn-json/basic/supported.ts", "../../../src/webauthn-json/extended/api.ts", "../../../src/webauthn-json/browser-ponyfill.ts", "../../../src/dev/demo/index.ts"],
  "sourcesContent": ["// This function does a simple check to test for the credential management API\n// functions we need, and an indication of public key credential authentication\n// support.\n// https://developers.google.com/web/updates/2018/03/webauthn-credential-management\n\nexport function supported(): boolean {\n  return !!(\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get &&\n    window.PublicKeyCredential\n  );\n}\n", "import {\n  base64urlToBuffer,\n  bufferToBase64url,\n  Base64urlString,\n} from \"../base64url\";\nimport { convert } from \"../convert\";\nimport { AuthenticatorAttestationResponseJSON } from \"../basic/json\";\nimport {\n  CredentialCreationOptionsExtendedJSON,\n  CredentialRequestOptionsExtendedJSON,\n  PublicKeyCredentialWithAssertionExtendedResultsJSON,\n  PublicKeyCredentialWithAttestationExtendedResultsJSON,\n  AuthenticatorAttestationResponseExtendedJSONCallable,\n  AuthenticatorAttestationResponseExtendedJSONCallablePartial,\n} from \"./json\";\nimport {\n  credentialCreationOptionsExtended,\n  credentialRequestOptionsExtended,\n  publicKeyCredentialWithAssertionExtended,\n  publicKeyCredentialWithAttestationExtended,\n} from \"./schema\";\n\n// create\n\nexport function createExtendedRequestFromJSON(\n  requestJSON: CredentialCreationOptionsExtendedJSON,\n): CredentialCreationOptions {\n  return convert(\n    base64urlToBuffer,\n    credentialCreationOptionsExtended,\n    requestJSON,\n  );\n}\n\nexport function createExtendedResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAttestationExtendedResultsJSON {\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAttestationExtended,\n    credential,\n  );\n}\n\ninterface AuthenticatorAttestationResponseExtendedCallablePartial {\n  getTransports?: () => string[];\n  getAuthenticatorData?: () => ArrayBuffer;\n  getPublicKey?: () => ArrayBuffer | null;\n  getPublicKeyAlgorithm?: () => COSEAlgorithmIdentifier;\n}\n\nfunction makeCallable(\n  jsonResponse: AuthenticatorAttestationResponseJSON,\n  credentialResponse: AuthenticatorAttestationResponseExtendedCallablePartial,\n): AuthenticatorAttestationResponseExtendedJSONCallable {\n  const callable: AuthenticatorAttestationResponseExtendedJSONCallablePartial =\n    {};\n\n  if (credentialResponse.getTransports) {\n    callable.getTransports = (): string[] => {\n      return credentialResponse.getTransports();\n    };\n  }\n\n  if (credentialResponse.getAuthenticatorData) {\n    callable.getAuthenticatorData = (): Base64urlString => {\n      return bufferToBase64url(credentialResponse.getAuthenticatorData());\n    };\n  }\n\n  if (credentialResponse.getPublicKey) {\n    callable.getPublicKey = (): Base64urlString => {\n      const publicKey = credentialResponse.getPublicKey();\n      return publicKey && bufferToBase64url(publicKey);\n    };\n  }\n\n  if (credentialResponse.getPublicKeyAlgorithm) {\n    callable.getPublicKeyAlgorithm = (): COSEAlgorithmIdentifier => {\n      return credentialResponse.getPublicKeyAlgorithm();\n    };\n  }\n\n  const newJSON = Object.create(callable);\n  Object.assign(newJSON, jsonResponse);\n  return newJSON;\n}\n\nexport async function createExtended(\n  requestJSON: CredentialCreationOptionsExtendedJSON,\n): Promise<PublicKeyCredentialWithAttestationExtendedResultsJSON> {\n  const credential = (await navigator.credentials.create(\n    createExtendedRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  const json = createExtendedResponseToJSON(credential);\n  json.response = makeCallable(\n    json.response,\n    credential.response as AuthenticatorAttestationResponseExtendedCallablePartial,\n  );\n  return json;\n}\n\n// get\n\nexport function getExtendedRequestFromJSON(\n  requestJSON: CredentialRequestOptionsExtendedJSON,\n): CredentialRequestOptions {\n  return convert(\n    base64urlToBuffer,\n    credentialRequestOptionsExtended,\n    requestJSON,\n  );\n}\n\nexport function getExtendedResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAssertionExtendedResultsJSON {\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAssertionExtended,\n    credential,\n  );\n}\n\nexport async function getExtended(\n  requestJSON: CredentialRequestOptionsExtendedJSON,\n): Promise<PublicKeyCredentialWithAssertionExtendedResultsJSON> {\n  const credential = (await navigator.credentials.get(\n    getExtendedRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return getExtendedResponseToJSON(credential);\n}\n", "import {\n  createExtendedRequestFromJSON as parseCreationOptionsFromJSON,\n  createExtendedResponseToJSON,\n  getExtendedRequestFromJSON as parseRequestOptionsFromJSON,\n  getExtendedResponseToJSON,\n  PublicKeyCredentialWithAssertionExtendedResultsJSON,\n  PublicKeyCredentialWithAttestationExtendedResultsJSON,\n  supported,\n} from \"./extended\";\n\nexport { parseCreationOptionsFromJSON, parseRequestOptionsFromJSON, supported };\n\nexport type PublicKeyCredentialJSON =\n  | PublicKeyCredentialWithAssertionExtendedResultsJSON\n  | PublicKeyCredentialWithAttestationExtendedResultsJSON;\n\nexport interface PublicKeyCredentialWithToJSON extends PublicKeyCredential {\n  toJSON(): PublicKeyCredentialJSON;\n}\n\nexport async function create(\n  options: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithToJSON> {\n  const response = (await navigator.credentials.create(\n    options,\n  )) as PublicKeyCredentialWithToJSON;\n  response.toJSON = () => createExtendedResponseToJSON(response);\n  return response;\n}\n\nexport async function get(\n  options: CredentialRequestOptions,\n): Promise<PublicKeyCredentialWithToJSON> {\n  const response = (await navigator.credentials.get(\n    options,\n  )) as PublicKeyCredentialWithToJSON;\n  response.toJSON = () => getExtendedResponseToJSON(response);\n  return response;\n}\n", "// A minimal example to test `webauthn-json`.\n// Note: do not hardcode values in production.\n\nimport { PublicKeyCredentialDescriptorJSON } from \"../../webauthn-json/basic/json\";\nimport { supported } from \"../../webauthn-json\";\nimport {\n  getRegistrations,\n  saveRegistration,\n  setRegistrations,\n  withStatus,\n} from \"./state\";\nimport {\n  parseCreationOptionsFromJSON,\n  create,\n  get,\n  parseRequestOptionsFromJSON,\n} from \"../../webauthn-json/browser-ponyfill\";\n\nfunction registeredCredentials(): PublicKeyCredentialDescriptorJSON[] {\n  return getRegistrations().map((reg) => ({\n    id: reg.rawId,\n    type: reg.type,\n  }));\n}\n\nasync function register(): Promise<void> {\n  const cco = parseCreationOptionsFromJSON({\n    publicKey: {\n      challenge: \"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\",\n      rp: { name: \"Localhost, Inc.\" },\n      user: {\n        id: \"IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\",\n        name: \"test_user\",\n        displayName: \"Test User\",\n      },\n      pubKeyCredParams: [{ type: \"public-key\", alg: -7 }],\n      excludeCredentials: registeredCredentials(),\n      authenticatorSelection: { userVerification: \"discouraged\" },\n      extensions: {\n        credProps: true,\n      },\n    },\n  });\n  saveRegistration(await create(cco));\n}\n\nasync function authenticate(): Promise<void> {\n  const cro = parseRequestOptionsFromJSON({\n    publicKey: {\n      challenge: \"CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\",\n      allowCredentials: registeredCredentials(),\n      userVerification: \"discouraged\",\n    },\n  });\n  await get(cro);\n}\n\nasync function clear(): Promise<void> {\n  setRegistrations([]);\n}\n\nasync function testSupported() {\n  document.querySelector(\"#supported .status\")!.textContent = \"\u2026\";\n  document.querySelector(\"#supported .status\")!.textContent = supported()\n    ? \" \u2705\"\n    : \" \u274C\";\n}\n\nwindow.addEventListener(\"load\", () => {\n  try {\n    document\n      .querySelector(\"#register\")!\n      .addEventListener(\"click\", withStatus(\"#register .status\", register));\n    document\n      .querySelector(\"#authenticate\")!\n      .addEventListener(\n        \"click\",\n        withStatus(\"#authenticate .status\", authenticate),\n      );\n    document\n      .querySelector(\"#clear\")!\n      .addEventListener(\"click\", withStatus(\"#clear .status\", clear));\n    document\n      .querySelector(\"#supported\")!\n      .addEventListener(\"click\", testSupported);\n  } catch (e) {\n    console.error(e);\n  }\n});\n"],
  "mappings": "iJAKO,YAA8B,CACnC,MAAO,CAAC,CACN,WAAU,aACV,UAAU,YAAY,QACtB,UAAU,YAAY,KACtB,OAAO,qBCcJ,WACL,EAC2B,CAC3B,MAAO,GACL,EACA,EACA,GAIG,WACL,EACuD,CACvD,MAAO,GACL,EACA,EACA,GAgEG,WACL,EAC0B,CAC1B,MAAO,GACL,EACA,EACA,GAIG,WACL,EACqD,CACrD,MAAO,GACL,EACA,EACA,GCpGJ,iBACE,EACwC,CACxC,GAAM,GAAY,KAAM,WAAU,YAAY,OAC5C,GAEF,SAAS,OAAS,IAAM,EAA6B,GAC9C,EAGT,iBACE,EACwC,CACxC,GAAM,GAAY,KAAM,WAAU,YAAY,IAC5C,GAEF,SAAS,OAAS,IAAM,EAA0B,GAC3C,ECnBT,YAAsE,CACpE,MAAO,KAAmB,IAAI,AAAC,GAAS,EACtC,GAAI,EAAI,MACR,KAAM,EAAI,QAId,kBAAyC,CACvC,GAAM,GAAM,EAA6B,CACvC,UAAW,CACT,UAAW,8CACX,GAAI,CAAE,KAAM,mBACZ,KAAM,CACJ,GAAI,8CACJ,KAAM,YACN,YAAa,aAEf,iBAAkB,CAAC,CAAE,KAAM,aAAc,IAAK,KAC9C,mBAAoB,IACpB,uBAAwB,CAAE,iBAAkB,eAC5C,WAAY,CACV,UAAW,OAIjB,EAAiB,KAAM,GAAO,IAGhC,kBAA6C,CAC3C,GAAM,GAAM,EAA4B,CACtC,UAAW,CACT,UAAW,8CACX,iBAAkB,IAClB,iBAAkB,iBAGtB,KAAM,GAAI,GAGZ,kBAAsC,CACpC,EAAiB,IAGnB,kBAA+B,CAC7B,SAAS,cAAc,sBAAuB,YAAc,SAC5D,SAAS,cAAc,sBAAuB,YAAc,IACxD,UACA,UAGN,OAAO,iBAAiB,OAAQ,IAAM,CACpC,GAAI,CACF,SACG,cAAc,aACd,iBAAiB,QAAS,EAAW,oBAAqB,IAC7D,SACG,cAAc,iBACd,iBACC,QACA,EAAW,wBAAyB,IAExC,SACG,cAAc,UACd,iBAAiB,QAAS,EAAW,iBAAkB,IAC1D,SACG,cAAc,cACd,iBAAiB,QAAS,SACtB,EAAP,CACA,QAAQ,MAAM",
  "names": []
}
